<!--
 * @Author: 黄遥
 * @Date: 2020-05-29 11:34:58
 * @LastEditors: 黄遥
 * @LastEditTime: 2020-05-30 14:25:02
 * @Description: file content
--> 
## 强缓存
当浏览器去请求某个文件的时候，服务端就在 reponse header 里面对该文件做了缓存设置。缓存时间、缓存类型都由服务端控制，具体表现为：
reponse header 的 cache-control，常见的设置是 max-age、private、no-cache、no-store 等

### 总结
1. cache-control: max-age=xxx, public 
客户端和代理服务器都可以缓存该资源；
客户端在 XXX 秒的有效期内，如果有请求资源的需求的话就直接读取缓存
如果用户做了刷新操作，就向服务器发起 http 请求

2. cache-control: max-age=XXX, private
只让客户端可以缓存该资源，代理服务器不缓存
客户端在XXX秒内直接读取缓存

3. cache-control: max-age=XXX, immutable
客户端在XXX秒的有效期内，如果有请求该资源的需求的话就直接读取缓存，即使用户做了刷新操作，也不向服务器发起http请求

4. cache-control: no-cache
跳过设置强缓存，但是不妨碍设置协商缓存，一般如果做了强缓存，只有在强缓存失效时，才会走协商缓存，设置了 no-cache 就不会走强缓存，每次请求都会询问服务端

5. cache-control: no-store
不缓存，这个会让客户端、服务器都不缓存，也就没有所谓的强缓存、协商缓存了

## 协商缓存
强缓存就是给资源设置个过期时间，客户端每次请求资源时都会看是否过期；只有在过期才会去询问服务器。所以，强缓存就是为了给客户端自给自足用的。而当某天，客户端请求该资源时发现其过期了，这是就会去请求服务器了，而这时候去请求服务器的这过程就可以设置协商缓存。这时候，协商缓存就是需要客户端和服务器两端进行交互的。
怎样设置协商缓存
```javascript
etag: '5c20abbd-e2e8'
last-modified: Mon, 24 Dec 2018 09:49:49 GMT
```
所以协商缓存步骤总结：

请求资源时，把用户本地该资源的 etag 同时带到服务端，服务端和最新资源做对比。
如果资源没更改，返回304，浏览器读取本地缓存。
如果资源有更改，返回200，返回最新的资源。

为什么要有 etag？
HTTP1.1中etag的出现（也就是说，etag是新增的，为了解决之前只有If-Modified的缺点）主要是为了解决几个last-modified比较难解决的问题：
1. 一些文件也许会周期性的更改，但是他的内容并不改变（仅仅改变的修改时间），这个时候我们并不希望客户端认为这个文件被修改了，而重新 get
2. 某些文件修改非常频繁，比如在秒以下的时间内进行修改，（比如说 1s 内修改了 N 次），if-midified-since 能检查到的粒度是秒级的，这种修改无法判断
3. 某些服务器不能精确的得到文件的最后修改时间


链接：https://www.jianshu.com/p/9c95db596df5
